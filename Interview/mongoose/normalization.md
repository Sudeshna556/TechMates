# Normalization 
## It is a technique to reduce or remove the data duplicancy and improve data consistency.

üîπ What is Normalization in Mongoose/MongoDB?
Normalization means structuring your data into separate collections (schemas) to avoid duplication and keep relationships clean. Instead of embedding large chunks of data everywhere, you store references (ObjectIds) and keep each entity in its own collection.

- Denormalization ‚Üí Embed related data inside a single document (e.g., user has an array of requests).
- Normalization ‚Üí Split into multiple collections and reference by IDs (e.g., UserSchema and ConnectionRequestSchema).

üîπ Why Normalize?
- Avoid duplication: Instead of storing the same user info in multiple requests, you just store the userId.
- Consistency: If a user updates their name/email, you don‚Äôt need to update every request document.
- Scalability: Queries on requests don‚Äôt require loading the entire user document.
- Flexibility: Easier to extend features like request history, notifications, or analytics.

üîπ Example: Normalized vs Denormalized
‚ùå Denormalized (all in one schema)
const UserSchema = new mongoose.Schema({
  name: String,
  email: String,
  requests: [
    {
      receiverName: String,
      status: String
    }
  ]
});


- Problem: If receiver changes their name, you must update every request.

const ConnectionRequestSchema = new mongoose.Schema({
  senderId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  receiverId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  status: { type: String, enum: ['pending', 'accepted', 'rejected'] }
});

What is Schema.Types.ObjectId?
- It‚Äôs a special type in Mongoose that represents a MongoDB ObjectId.
- An ObjectId is a 12‚Äëbyte unique identifier automatically generated by MongoDB for each document.
- In schemas, you use it to reference another document in a different collection.

üîπ Why Use It?
- To create relationships between collections (like foreign keys in SQL).
- Keeps data normalized: instead of embedding entire user objects, you store their _id.

üîπ Example in Practice


// Connection Request Schema
const ConnectionRequestSchema = new mongoose.Schema({
  senderId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  receiverId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  status: { type: String, enum: ['pending', 'accepted', 'rejected'] }
});

- Here, senderId and receiverId are ObjectIds pointing to documents in the User collection.
- The ref: 'User' tells Mongoose which model to link to.

üîπ How .populate() Uses It
const request = await ConnectionRequest
  .findOne({ status: 'pending' })
  .populate('senderId receiverId');


- Without populate ‚Üí you just get ObjectIds.
- With populate ‚Üí Mongoose replaces those ObjectIds with full user documents.

üîπ Analogy
Think of ObjectId as a library card number:
- Each user (book) has a unique card number (ObjectId).
- A connection request (borrowing slip) doesn‚Äôt store the whole book ‚Äî it just stores the card number.
- When needed, you can look up the book details using that card number (populate).

‚úÖ So, mongoose.Schema.Types.ObjectId is the glue that lets you normalize schemas and still query across them easily.



- Here, requests reference users by ID.
- You can populate() to fetch user details when needed:
ConnectionRequest.find().populate('senderId receiverId');


üîπ When to Normalize vs Denormalize
 Normalize when:
- Data is reused in many places.
- Updates should propagate consistently.
- Relationships are many‚Äëto‚Äëmany (like users ‚Üî requests).
 Denormalize when:
- Data is small and rarely changes.
- You want faster reads with fewer joins/populates.
- Example: embedding user‚Äôs last login info inside a request.




